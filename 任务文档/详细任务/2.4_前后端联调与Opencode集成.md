# 2.4 前后端联调与 Opencode (Code Interpreter) 集成设计

## 1. 目标与背景
用户希望在现有的 `atoms-demo` 平台上，实现生成完整的 **全栈应用 (Frontend + Backend)**，并不仅限于静态的前端代码。同时，用户希望能够 **"安装 Opencode"** 以实现与应用的深度交互。

**核心需求**:
1.  **全栈连通 (Connectivity)**: 前端 (Sandpack/Browser) 需要能访问 后端 (Docker Container)。
2.  **Opencode 交互 (Interaction)**: 在应用环境中集成类似 Code Interpreter 的能力，允许通过能够执行代码的 Agent 进行自然语言交互。

## 2. 技术名词澄清
*   **Opencode**: 在此上下文中，理解为 **"开放式代码执行环境 (Open Code Execution Environment)"** 或 **Open Interpreter** 类工具。它不仅仅是一个终端，而是一个能理解自然语言并将其转化为环境内代码执行的 Agent。
*   **Sandpack**: 我们的前端代码预览环境。
*   **Docker Sandbox**: 我们的后端代码执行环境。

## 3. 总体架构设计

### 3.1 架构图
```mermaid
graph TD
    User[用户] --> |Chat / UI| MainApp[Atoms-Demo (Next.js)]
    User --> |Preview| Sandpack[前端预览 (Browser)]
    
    subgraph "Main Application (The Brain)"
        Proxy[API Gateway]
        Agent[Opencode Agent Logic (AI SDK)]
    end
    
    subgraph "Docker Sandbox (The Hands)"
        Container[App Container]
        Exec[Code Execution Runtime]
    end
    
    Sandpack --> |API Request| Proxy
    Proxy --> |Forward| Container
    
    MainApp --> |Stream Text/Tools| Agent
    Agent --> |Execute Code| Exec
    Exec --> |Return Result| Agent
```

### 3.2 关键模块设计

#### A. Chat 即 Opencode (Chat-First Experience)
用户明确要求 **"Opencode直接接管对话界面"**，因此不再提供 "Terminal 里的 CLI 工具"。整个 Chat 界面就是一个拥有代码执行能力的 Agent。

1.  **交互模式**:
    *   用户在 Chat 输入: "分析这个数据文件"
    *   **后端 Agent**: 自动判断需要写代码 -> 生成 Python 代码 -> 调用 Docker Exec 执行。
    *   **前端 Chat UI**: 展示 "正在编写代码...", "代码执行中...", "执行结果: [图表/文本]"。
    *   **无感知启动**: 用户不需要手动输入 `interpreter`，Agent 默认拥有此能力。

#### B. 前后端连通 (Reverse Proxy)
*(保持不变: 使用 /api/proxy 解决 Sandpack 访问容器后端的问题)*

### 3.2 关键模块设计

#### A. 前后端连通 (The "Chain Up" Solution)
为了解决浏览器端 (Sandpack) 无法直接连接封闭容器的问题，采用 **反向代理模式**。

1.  **代理路由**:
    在 `src/app/api/proxy/[projectId]/[...path]/route.ts` 建立通用代理。
    *   **Public URL**: `https://atoms-demo.com/api/proxy/proj-123/api/users`
    *   **Internal URL**: `http://172.17.0.x:3000/api/users` (Docker Internal IP)

2.  **Sandpack 配置**:
    生成的代码中，需自动注入 API Base URL 配置。
    ```javascript
    // 自动生成的 config.js
    export const API_BASE_URL = "/api/proxy/proj-123";
    ```
    或者在 Vite/Next.js 配置中设置代理转发。

#### C. Agent 实现方案
我们将在 `src/app/api/chat` 中集成 Opencode 逻辑，而不是单纯转发给 LLM。

1.  **AI SDK Tool Calling**:
    *   定义 `execute_python` 和 `execute_bash` 工具。
    *   System Prompt: "你是一个全能的全栈工程师。你可以通过执行 Python 代码来计算、处理数据或操作文件。请优先使用代码解决复杂逻辑问题。"

2.  **执行环境**:
    *   利用现有的 `SandboxManager`。
    *   `execute_python` -> `docker exec python3 -c "..."`。

## 4. 详细实施计划

### Phase 1: 基础设施 (Infrastructure)
*   [ ] **网络与代理**: 配置 Docker 网络及 Next.js Reverse Proxy。

### Phase 2: Agent 核心逻辑 (The Brain)
*   [ ] **Tool 增强**: 在 `tools.ts` 中增强 `executeBash`，增加 `executePython` (支持多行、状态保持/REPL 模拟是难点，初期可先做 Stateless Script)。
*   [ ] **Prompt 调整**: 修改 System Prompt，赋予 AI "Code Interpreter" 的人设。

### Phase 3: 前端体验 (The Face)
*   [ ] **执行状态可视化**:
    *   当 Agent 调用 `execute_*` 工具时，前端不再只是显示 Loading。
    *   显示 "Thinking Code" -> "Running Code" -> "Output"。
    *   (可选) 类似于 V0/Bolt 的 "Process" 折叠面板。

## 4. 详细实施计划

### Phase 1: 基础设施升级 (Infrastructure)
*   [ ] **Docker 网络配置**: 确保所有 Sandbox 容器加入同一 Bridge 网络，以便 Next.js 应用可以通过 IP 访问它们。
*   [ ] **Proxy API 开发**: 实现 `src/app/api/proxy` 路由，处理请求转发、鉴权和错误处理。

### Phase 2: 全栈生成逻辑 (Generation Logic)
*   [ ] **Prompt 优化**: 更新 System Prompt，教 AI 如何生成“前后端分离但连通”的代码。
    *   告诉 AI: "前端 fetch 请使用相对路径或环境变量"。
    *   告诉 AI: "后端请监听 0.0.0.0 而不是 127.0.0.1"。
*   [ ] **多容器模板**: 定义 Fullstack 模板（如 React + Express, Vue + FastAPI）。

### Phase 3: Opencode 深度集成 (Integration)
*   [ ] **镜像构建**: 制作包含 Python/Node/AI-Tools 的 `atoms-sandbox:full` 镜像。
*   [ ] **交互界面**: 在 IDE 布局的下方或侧边增加 "Console/Terminal" 面板。
*   [ ] **Agent 桥接**: 编写中间件，让 Chat 窗口可以直接投递任务给容器内的 Opencode Agent。

## 5. 安全与权限 (Security & Isolation)

为了确保 Opencode (Agent) 的权限被严格限制在沙盒内，我们将采用 **多层防御 (Defense in Depth)** 策略：

### 5.1 容器级隔离 (Level 1: Container)
*   **Docker Isolation**: 容器本身是第一道防线。Agent 无法访问宿主机的任何文件，除非显式 Mount。
*   **Resource Limits**: 限制 CPU/Memory 配额，防止 Agent 运行恶意死循环耗尽服务器资源。

### 5.2 用户权限隔离 (Level 2: User Permissions)
*   **Non-Root User**: 容器内 **严禁使用 root 运行 Agent**。
*   **Dedicated User**: 创建名为 `sandbox_user` 的普通用户。
*   **Permission Setup**:
    *   `/workspace`: `sandbox_user` 拥有读写权限 (755).
    *   `/ (System Root)`: `sandbox_user` **只读** (Read-Only) 或 **不可访问**。
    *   敏感目录 (`/etc`, `/proc`, `/sys`): 通过 Docker 安全配置 (`--cap-drop=ALL`) 和文件系统权限进行屏蔽。

### 5.3 Agent 配置 (Level 3: Application)
*   **Safe Mode**: 启用 Agent 的安全模式 (如 `open-interpreter --safe`)，禁止执行高危系统命令。
*   **System Prompt**: 强制设置 Agent 的 System Instruction，明确告知 "你只能操作 /workspace 目录下的文件，禁止访问其他路径"。

### 5.4 网络隔离 (Level 4: Network)
*   **Egress Control**: 限制容器的出站流量。除了必要的 PyPI/NPM 下载源外，禁止访问内网其他 IP。

## 6. 常见问题解答 (FAQ)

**Q: 为什么要用 Proxy 而不是直接暴露端口？**
A: Docker 动态暴露端口管理复杂且有安全风险（端口扫描）。通过统一的 Proxy 路由不仅安全，还能方便地进行鉴权和流量控制。

**Q: Opencode 会很重吗？**
A: 取决于集成方式。如果只是作为 CLI 工具按需调用，资源消耗可控。如果是常驻进程，需要关注内存使用。建议采用按需启动的模式。

**Q: 如何验证成功？**
A: 
1. 生成一个计数器应用（React + Node）。
2. 点击前端 "+" 按钮。
3. 刷新页面，数字依然保留（证明后端数据库/内存生效）。
4. 在终端输入 "Reset counter"，数字归零（证明 Opencode 交互生效）。
